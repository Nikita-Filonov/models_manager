{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Library which provide us abstraction, json generation, json schema validation, database querying Install library pip install models-manager","title":"Home"},{"location":"#install-library","text":"pip install models-manager","title":"Install library"},{"location":"enums/","text":"Inside the library there is a wrapper over the standard Python enum object. The wrapper extends the functionality of the standard enum, this is done for ease of use. from models_manager import FieldGenericEnum class Roles ( FieldGenericEnum ): JUNIOR = 'junior' MIDDLE = 'middle' SENIOR = 'senior' EXPERT = 'expert' Roles . to_list () [ 'junior' , 'middle' , 'senior' , 'expert' ] Roles . to_list ( exclude = [ Roles . EXPERT ]) [ 'junior' , 'middle' , 'senior' ]","title":"Enums"},{"location":"examples/","text":"With object annotation Let's create an example test that uses models, validation, and json generation. Imagine that we have several endpoints that allow us to manipulate the user Method Endpoint Body GET /users None POST /users {'id': 1, 'username': 'some', 'email': 'other'} PUT /users/{user_id} {'id': 1, 'username': 'some', 'email': 'other'} This is what the user object looks like Field Type Value id number Any integer username string Any string email string Email string Let's start by creating a model /models/user.py from models_manager import Model , Field from models_manager.utils import random_number , random_string def get_email () -> str : \"\"\"Generates random email\"\"\" return random_string () + '@gmail.com' class User ( Model ): id = Field ( default = random_number , json = 'id' , category = int ) username = Field ( default = random_string , json = 'username' , category = str ) email = Field ( default = get_email , json = 'email' , category = str ) /api/users.py from models.user import User from requests import get , post , put , Response def get_users () -> Response : return get ( '/users' ) def create_user ( user : User ) -> Response : json = user . manager . to_json return post ( '/users' , json = json ) def update_user ( user_id : int , user : User ) -> Response : json = user . manager . to_json return put ( f '/users/ { user_id } ' , json = json ) tests/conftest.py import pytest from models.user import User @pytest . fixture ( scope = 'function' ) def user () -> User : user_object = User ( ** User . manager . to_json ) user_json = create_user ( user_object ) . json () return User ( ** user_json ) tests/test_user.py from http import HTTPStatus import pytest from api.users import get_users , create_user from assertions import validate_json from models.user import User @pytest . mark . users class TestUser : def test_get_users ( self ): response = get_users () json_response = response . json () assert response . status_code == HTTPStatus . OK validate_json ( json_response , User . manager . to_array_schema ) def test_create_user ( self ): user = User ( ** User . manager . to_json ) response = create_user ( user ) json_response = response . json () assert response . status_code == HTTPStatus . CREATED assert user . id . value == json_response [ user . id . json ] assert user . username . value == json_response [ user . username . json ] assert user . email . value == json_response [ user . email . json ] validate_json ( json_response , user . manager . to_schema ) def test_update_user ( self , user : User ): # user object created by fixture # creating new user object, with new values, for updating update_user = User ( ** User . manager . to_json ) # user.id.value - value from fixture # updated_user - the user object we use to update response = update_user ( user . id . value , update_user ) json_response = response . json () assert response . status_code == HTTPStatus . OK assert user . id . value == json_response [ user . id . json ] # usually we not updating ID assert update_user . username . value == json_response [ user . username . json ] assert update_user . email . value == json_response [ user . email . json ] validate_json ( json_response , user . manager . to_schema ) This example is just a sample of how the models can be used. In fact, the scope is much wider. Some methods in this example can be overwritten. Let's look at how we can rewrite the user update test In update_user we can use just object to update user def update_user ( user : User ) -> Response : json = user . manager . to_json return put ( f '/users/ { user . id . value } ' , json = json ) Then our tests would look like class TestUser : ... def test_update_user ( self , user : User ): # user object created by fixture # now we overriding id of update_user object update_user = User ( ** User . manager . to_json , id = user . id . value ) response = update_user ( update_user ) json_response = response . json () assert response . status_code == HTTPStatus . OK assert update_user . id . value == json_response [ user . id . json ] assert update_user . username . value == json_response [ user . username . json ] assert update_user . email . value == json_response [ user . email . json ] validate_json ( json_response , user . manager . to_schema )","title":"Examples"},{"location":"examples/#with-object-annotation","text":"Let's create an example test that uses models, validation, and json generation. Imagine that we have several endpoints that allow us to manipulate the user Method Endpoint Body GET /users None POST /users {'id': 1, 'username': 'some', 'email': 'other'} PUT /users/{user_id} {'id': 1, 'username': 'some', 'email': 'other'} This is what the user object looks like Field Type Value id number Any integer username string Any string email string Email string Let's start by creating a model /models/user.py from models_manager import Model , Field from models_manager.utils import random_number , random_string def get_email () -> str : \"\"\"Generates random email\"\"\" return random_string () + '@gmail.com' class User ( Model ): id = Field ( default = random_number , json = 'id' , category = int ) username = Field ( default = random_string , json = 'username' , category = str ) email = Field ( default = get_email , json = 'email' , category = str ) /api/users.py from models.user import User from requests import get , post , put , Response def get_users () -> Response : return get ( '/users' ) def create_user ( user : User ) -> Response : json = user . manager . to_json return post ( '/users' , json = json ) def update_user ( user_id : int , user : User ) -> Response : json = user . manager . to_json return put ( f '/users/ { user_id } ' , json = json ) tests/conftest.py import pytest from models.user import User @pytest . fixture ( scope = 'function' ) def user () -> User : user_object = User ( ** User . manager . to_json ) user_json = create_user ( user_object ) . json () return User ( ** user_json ) tests/test_user.py from http import HTTPStatus import pytest from api.users import get_users , create_user from assertions import validate_json from models.user import User @pytest . mark . users class TestUser : def test_get_users ( self ): response = get_users () json_response = response . json () assert response . status_code == HTTPStatus . OK validate_json ( json_response , User . manager . to_array_schema ) def test_create_user ( self ): user = User ( ** User . manager . to_json ) response = create_user ( user ) json_response = response . json () assert response . status_code == HTTPStatus . CREATED assert user . id . value == json_response [ user . id . json ] assert user . username . value == json_response [ user . username . json ] assert user . email . value == json_response [ user . email . json ] validate_json ( json_response , user . manager . to_schema ) def test_update_user ( self , user : User ): # user object created by fixture # creating new user object, with new values, for updating update_user = User ( ** User . manager . to_json ) # user.id.value - value from fixture # updated_user - the user object we use to update response = update_user ( user . id . value , update_user ) json_response = response . json () assert response . status_code == HTTPStatus . OK assert user . id . value == json_response [ user . id . json ] # usually we not updating ID assert update_user . username . value == json_response [ user . username . json ] assert update_user . email . value == json_response [ user . email . json ] validate_json ( json_response , user . manager . to_schema ) This example is just a sample of how the models can be used. In fact, the scope is much wider. Some methods in this example can be overwritten. Let's look at how we can rewrite the user update test In update_user we can use just object to update user def update_user ( user : User ) -> Response : json = user . manager . to_json return put ( f '/users/ { user . id . value } ' , json = json ) Then our tests would look like class TestUser : ... def test_update_user ( self , user : User ): # user object created by fixture # now we overriding id of update_user object update_user = User ( ** User . manager . to_json , id = user . id . value ) response = update_user ( update_user ) json_response = response . json () assert response . status_code == HTTPStatus . OK assert update_user . id . value == json_response [ user . id . json ] assert update_user . username . value == json_response [ user . username . json ] assert update_user . email . value == json_response [ user . email . json ] validate_json ( json_response , user . manager . to_schema )","title":"With object annotation"},{"location":"field/","text":"Field is an object that describes a model field category Category argument, which is responsible for the field value type. The following categories are supported: Type Description Schema int Integer numbers 1 , 2 , 3 , 4 number float Float numbers 1.5 , 2.6 , 7.8 number str Strings \"some\" , \"other\" string bool Boolean True/False boolean list List of dicts/strings/integers [1, 2, 3] , [\"1\", \"2\", \"3\"] array tuple Tuple of dicts/strings/integers (1, 2, 3) , (\"1\", \"2\", \"3\") array dict Dict {\"key\": \"value\"} object None None null Let's take a simple example from models_manager import Model , Field class User ( Model ): username = Field ( default = 1 , json = 'username' , category = str ) email = Field ( default = 2 , json = 'email' , category = int ) User . manager . to_json { 'username' : '1' , 'email' : 2 } default Default field value. Can be any of supported objects. Provides a default value that will be used to generate json and insert it into the database. By default default argument equal to None str , int , float , list , dict , bool , Callable , None Basic Let's look at a simple example with a default value from models_manager import Field items = Field ( default = 12345 ) items . get_default \"12345\" Warning Note that the \"12345\" object is a string. This happens because we did not pass the category. And by default string category is used Let's add a category to our field from models_manager import Field items = Field ( default = 12345 , category = int ) items . get_default 12345 Note Now we get the value as a integer Callable Example with callable object from models_manager import Field def get_items_from_api (): \"\"\"Some function which will get items from API\"\"\" return get_items () . json () items = Field ( default = get_items_from_api , category = list ) items . get_default [ { 'key' : 'value1' }, { 'key' : 'value2' }, { 'key' : 'value3' } ] Let's explain what's going on here. The get_items_from_api function gets a list of items and this function is callable object . This function is calling when we call the get_default method json The json argument is responsible for how the field in json will be named. Json argument is using when generating json and schema. Let's take a simple example. Imagine we have a user object { \"id\" : 1 , \"firstName\" : \"some\" , \"lastName\" : \"other\" } Let's create a model that will describe the user object above. from models_manager import Field , Model class User ( Model ): id = Field ( json = 'id' ) first_name = Field ( json = 'firstName' ) last_name = Field ( json = 'lastName' ) User . manager . to_json { 'id' : None , 'firstName' : None , 'lastName' : None } Note Pay attention to how the model fields are naming in the class and in json. The naming is different, because, as a rule, the front end requires fields named in the javascript style, but we work with Python code and the javascript style is not suitable from models_manager import Field , Model class GoodUser ( Model ): first_name = Field ( json = 'firstName' ) # good class BadUser ( Model ): firstName = Field ( json = 'firstName' ) # very bad value The value argument that is responsible for the current value of the field. Unlike the default, value can change. Let's take an example of using value from models_manager import Field username = Field ( default = 'some' ) username . value = 'new value' username . get_default 'some' username . value 'new value' As we can see, the default value does not change, unlike value, which we can change and save the current state of the field into it. Now let's look at a more complex example with a model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' ) new_user = User ( id = 2 , username = 'other' ) new_user . username . value # username has new value 'other' new_user . manager . to_json # json of new_user object { 'id' : 2 , 'username' : 'other' } User . manager . to_json # json with default values { 'id' : 1 , 'username' : 'some' } From the example above, new_user is already a new object that has its own attributes. This object can be used as an annotation. Also, the new_user object contains the new id , username values that we passed when initializing the object. null The null argument controls whether the field can be null - essentially empty. For example, if we specify that the field is null=True , then this will affect the schema generation. Let's take a simple example from models_manager import Field username = Field ( category = str , json = 'username' , null = True ) username . get_schema { 'type' : [ 'string' , 'null' ] } It can be seen from the example above that if we add the null=True argument to the field. Then when generating the schema, we will get the variability of the field values string or null choices The choices argument is responsible for the variability of field values. for example, if the field has only a certain range of values. Let's look at an example from models_manager import Model , Field , FieldGenericEnum class ProjectStates ( FieldGenericEnum ): \"\"\"This is some states of the project\"\"\" STARTING = 1 PENDING = 2 STARTED = 3 CLOSED = 4 STOPPED = 5 class Project ( Model ): title = Field ( json = 'title' , category = str ) state = Field ( json = 'state' , choices = ProjectStates . to_list (), category = int ) Now, when creating an object or generating a schema, it will validate that the state field has a certain set of values. Let's look at an example of creating an object from models_manager import Model , Field , FieldGenericEnum class ProjectStates ( FieldGenericEnum ): \"\"\"This is some states of the project\"\"\" STARTING = 1 PENDING = 2 STARTED = 3 CLOSED = 4 STOPPED = 5 class Project ( Model ): title = Field ( json = 'title' , category = str ) state = Field ( json = 'state' , choices = ProjectStates . to_list (), category = int ) project_json = get_project ( id = 1 ) . json () { \"title\" : \"some\" , \"state\" : 7 } Project ( ** project_json ) # will raise an exception, because 7 is not valid state 'FieldException: The \"state\" field must be one of the 1, 2, 3, 4, 5, but 6 was received' related_to The related_to attribute is using to describe nested entities. For example, if json has a complex nested structure, then we can describe it using this attribute. Let's imagine that we have an API that returns an object with multiple nesting. { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"tenant\" : { \"id\" : 1 , \"name\" : \"Customer\" }, \"roles\" : [ { \"id\" : 1 , \"name\" : \"Junior\" , \"permissions\" : [ { \"id\" : 1 , \"action\" : \"Read\" } ] }, { \"id\" : 2 , \"name\" : \"Middle\" , \"permissions\" : [ { \"id\" : 1 , \"action\" : \"Read\" }, { \"id\" : 2 , \"action\" : \"Create\" } ] } ] } Let's describe this json object in the form of models from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class Permission ( Model ): id = Field ( json = 'id' , category = int ) action = Field ( json = 'action' , category = str ) class Role ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) permissions = Field ( json = 'permissions' , related_to = Permission , category = list ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenant = Field ( json = 'tenant' , category = dict , related_to = Tenant ) roles = Field ( json = 'roles' , category = list , related_to = Role ) only_json The only_json argument is using for the database. For example, if we have a field that is displayed in the json object, but it is not in the database. For example, consider a json object and a table in a database { \"id\" : 1 , \"username\" : \"some\" , \"token\" : \"some-token which is not in database\" } id username 1 some1 2 some2 3 some3 As we can see, the token field is not storing in the database, it can be dynamically calculated or cached from models_manager import Model , Field class UserWithToken ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) token = Field ( json = 'token' , only_json = True , category = str ) We described the model and specified only_json=True in the token field, now for any operation to the database, the token field will not be used is_related The is_related argument is responsible for the optionality of the field in the json object. If is_related=True , then this means that the field may not be present in the json object max_length The max_length argument, which is usually used for string fields and indicates the maximum length of the string field value","title":"Field"},{"location":"field/#category","text":"Category argument, which is responsible for the field value type. The following categories are supported: Type Description Schema int Integer numbers 1 , 2 , 3 , 4 number float Float numbers 1.5 , 2.6 , 7.8 number str Strings \"some\" , \"other\" string bool Boolean True/False boolean list List of dicts/strings/integers [1, 2, 3] , [\"1\", \"2\", \"3\"] array tuple Tuple of dicts/strings/integers (1, 2, 3) , (\"1\", \"2\", \"3\") array dict Dict {\"key\": \"value\"} object None None null Let's take a simple example from models_manager import Model , Field class User ( Model ): username = Field ( default = 1 , json = 'username' , category = str ) email = Field ( default = 2 , json = 'email' , category = int ) User . manager . to_json { 'username' : '1' , 'email' : 2 }","title":"category"},{"location":"field/#default","text":"Default field value. Can be any of supported objects. Provides a default value that will be used to generate json and insert it into the database. By default default argument equal to None str , int , float , list , dict , bool , Callable , None","title":"default"},{"location":"field/#basic","text":"Let's look at a simple example with a default value from models_manager import Field items = Field ( default = 12345 ) items . get_default \"12345\" Warning Note that the \"12345\" object is a string. This happens because we did not pass the category. And by default string category is used Let's add a category to our field from models_manager import Field items = Field ( default = 12345 , category = int ) items . get_default 12345 Note Now we get the value as a integer","title":"Basic"},{"location":"field/#callable","text":"Example with callable object from models_manager import Field def get_items_from_api (): \"\"\"Some function which will get items from API\"\"\" return get_items () . json () items = Field ( default = get_items_from_api , category = list ) items . get_default [ { 'key' : 'value1' }, { 'key' : 'value2' }, { 'key' : 'value3' } ] Let's explain what's going on here. The get_items_from_api function gets a list of items and this function is callable object . This function is calling when we call the get_default method","title":"Callable"},{"location":"field/#json","text":"The json argument is responsible for how the field in json will be named. Json argument is using when generating json and schema. Let's take a simple example. Imagine we have a user object { \"id\" : 1 , \"firstName\" : \"some\" , \"lastName\" : \"other\" } Let's create a model that will describe the user object above. from models_manager import Field , Model class User ( Model ): id = Field ( json = 'id' ) first_name = Field ( json = 'firstName' ) last_name = Field ( json = 'lastName' ) User . manager . to_json { 'id' : None , 'firstName' : None , 'lastName' : None } Note Pay attention to how the model fields are naming in the class and in json. The naming is different, because, as a rule, the front end requires fields named in the javascript style, but we work with Python code and the javascript style is not suitable from models_manager import Field , Model class GoodUser ( Model ): first_name = Field ( json = 'firstName' ) # good class BadUser ( Model ): firstName = Field ( json = 'firstName' ) # very bad","title":"json"},{"location":"field/#value","text":"The value argument that is responsible for the current value of the field. Unlike the default, value can change. Let's take an example of using value from models_manager import Field username = Field ( default = 'some' ) username . value = 'new value' username . get_default 'some' username . value 'new value' As we can see, the default value does not change, unlike value, which we can change and save the current state of the field into it. Now let's look at a more complex example with a model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' ) new_user = User ( id = 2 , username = 'other' ) new_user . username . value # username has new value 'other' new_user . manager . to_json # json of new_user object { 'id' : 2 , 'username' : 'other' } User . manager . to_json # json with default values { 'id' : 1 , 'username' : 'some' } From the example above, new_user is already a new object that has its own attributes. This object can be used as an annotation. Also, the new_user object contains the new id , username values that we passed when initializing the object.","title":"value"},{"location":"field/#null","text":"The null argument controls whether the field can be null - essentially empty. For example, if we specify that the field is null=True , then this will affect the schema generation. Let's take a simple example from models_manager import Field username = Field ( category = str , json = 'username' , null = True ) username . get_schema { 'type' : [ 'string' , 'null' ] } It can be seen from the example above that if we add the null=True argument to the field. Then when generating the schema, we will get the variability of the field values string or null","title":"null"},{"location":"field/#choices","text":"The choices argument is responsible for the variability of field values. for example, if the field has only a certain range of values. Let's look at an example from models_manager import Model , Field , FieldGenericEnum class ProjectStates ( FieldGenericEnum ): \"\"\"This is some states of the project\"\"\" STARTING = 1 PENDING = 2 STARTED = 3 CLOSED = 4 STOPPED = 5 class Project ( Model ): title = Field ( json = 'title' , category = str ) state = Field ( json = 'state' , choices = ProjectStates . to_list (), category = int ) Now, when creating an object or generating a schema, it will validate that the state field has a certain set of values. Let's look at an example of creating an object from models_manager import Model , Field , FieldGenericEnum class ProjectStates ( FieldGenericEnum ): \"\"\"This is some states of the project\"\"\" STARTING = 1 PENDING = 2 STARTED = 3 CLOSED = 4 STOPPED = 5 class Project ( Model ): title = Field ( json = 'title' , category = str ) state = Field ( json = 'state' , choices = ProjectStates . to_list (), category = int ) project_json = get_project ( id = 1 ) . json () { \"title\" : \"some\" , \"state\" : 7 } Project ( ** project_json ) # will raise an exception, because 7 is not valid state 'FieldException: The \"state\" field must be one of the 1, 2, 3, 4, 5, but 6 was received'","title":"choices"},{"location":"field/#related_to","text":"The related_to attribute is using to describe nested entities. For example, if json has a complex nested structure, then we can describe it using this attribute. Let's imagine that we have an API that returns an object with multiple nesting. { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"tenant\" : { \"id\" : 1 , \"name\" : \"Customer\" }, \"roles\" : [ { \"id\" : 1 , \"name\" : \"Junior\" , \"permissions\" : [ { \"id\" : 1 , \"action\" : \"Read\" } ] }, { \"id\" : 2 , \"name\" : \"Middle\" , \"permissions\" : [ { \"id\" : 1 , \"action\" : \"Read\" }, { \"id\" : 2 , \"action\" : \"Create\" } ] } ] } Let's describe this json object in the form of models from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class Permission ( Model ): id = Field ( json = 'id' , category = int ) action = Field ( json = 'action' , category = str ) class Role ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) permissions = Field ( json = 'permissions' , related_to = Permission , category = list ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenant = Field ( json = 'tenant' , category = dict , related_to = Tenant ) roles = Field ( json = 'roles' , category = list , related_to = Role )","title":"related_to"},{"location":"field/#only_json","text":"The only_json argument is using for the database. For example, if we have a field that is displayed in the json object, but it is not in the database. For example, consider a json object and a table in a database { \"id\" : 1 , \"username\" : \"some\" , \"token\" : \"some-token which is not in database\" } id username 1 some1 2 some2 3 some3 As we can see, the token field is not storing in the database, it can be dynamically calculated or cached from models_manager import Model , Field class UserWithToken ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) token = Field ( json = 'token' , only_json = True , category = str ) We described the model and specified only_json=True in the token field, now for any operation to the database, the token field will not be used","title":"only_json"},{"location":"field/#is_related","text":"The is_related argument is responsible for the optionality of the field in the json object. If is_related=True , then this means that the field may not be present in the json object","title":"is_related"},{"location":"field/#max_length","text":"The max_length argument, which is usually used for string fields and indicates the maximum length of the string field value","title":"max_length"},{"location":"providers/","text":"Within the library, providers are used to generate some values. For example, NegativeValuesProvider is used to generate negative values. If you want to change/extend/override the standard behavior, then you can inherit from the base Provider and override the methods you need","title":"Providers"},{"location":"database/connect/","text":"Connect is a class for establishing a database connection and also for interacting with the database. Each model internally uses the Connect class. Connect can establish multiple connections to different databases at the same time. Let's analyze a simple example for interacting with the database through the context manager from models_manager import Connect with Connect ( dbname = 'stuff' , is_lazy = False ) as query : result = query ( 'SELECT * FROM \"user\"' ) Output the result from models_manager import Connect with Connect ( dbname = 'stuff' , is_lazy = False ) as query : result = query ( 'SELECT * FROM \"user\"' ) for user in result : print ( user ) ( 1 , 'username1' , 'email1' ) ( 2 , 'username2' , 'email2' ) ( 3 , 'username3' , 'email3' ) ... Result serialization from models_manager import Connect from models_manager.utils import serializer with Connect ( dbname = 'stuff' , is_lazy = False ) as query : result = query ( 'SELECT * FROM \"user\"' ) for user in serializer ( result , many = True ): print ( user ) { 'id' : 1 , 'username' : 'username1' , 'email' : 'email1' } { 'id' : 2 , 'username' : 'username2' , 'email' : 'email2' } { 'id' : 3 , 'username' : 'username3' , 'email' : 'email3' } ...","title":"Connect"},{"location":"database/crud/","text":"Let's create a simple table and use it as an example to analyze the operations of reading, creating, updating, deleting Our \"user\" database table id username email 1 some1 email1 2 some2 email2 3 some3 email3 Our python model from models_manager import Model , Field from models_manager.utils import random_number , random_string class User ( Model ): identity = 'users' database = 'stuff' id = Field ( default = random_number , category = int ) username = Field ( default = random_string , category = str ) email = Field ( default = random_string , category = str ) def __str__ ( self ): return f '<User: { self . id } >' Get Get always returns a single object. If the requested object is not in the database, it will raise an error User . manager . get ( id = 1 ) # returns python dict { 'id' : 1 , 'username' : 'some1' , 'email' : 'email1' } User . manager . get ( id = 1 , as_json = False ) # returns user object '<User: 1>' User . manager . get ( id = 100 ) # user with id 100 does not exists \"ModelDoesNotExists: 'User' with {'id': 100} does not exists\" Filter Filter returns a list of objects. If the objects are not found in the database, it will return an empty list User . manager . filter ( id = 1 ) # returns python list of dicts [ { 'id' : 1 , 'username' : 'some1' , 'email' : 'email1' } ] User . manager . filter ( id__in = ( 1 , 2 ), as_json = False ) # returns list of user objects [ '<User: 1>' , '<User: 2>' ] # no such users in our database, filter will return empty list User . manager . filter ( id__in = ( 100 , 200 )) [] Create Creates an object and returns the created object. Values for creation are taken from the fields of the model User . manager . create () # create user with some random values { 'id' : 9 , 'username' : 'pF8i78S0ncdatjR5UDYE6uMDg5yxEwLk' , 'email' : 'i7KbUPGrNGBr5yW9mu6lD6JPMxX3FnKCaTQlSuwR9fLM' } # override username with custom value, instead of random User . manager . create ( username = 'custom' ) { 'id' : 32 , 'username' : 'custom' , 'email' : 'BzpzI8cc54ztqJLCgo7gUCYe8BhGzZxgt7c63l' } User . manager . create ( id = 100 , as_json = False ) # returns user object '<User: 100>' Update Allows you to update the object. Returns the updated object user = User . manager . get ( id = 1 , as_json = False ) user = user . manager . update ( username = 'new_username' , as_json = False ) user # returns user object '<User: 1>' user . username # updated username value 'new_username' Delete Removes an object from the database. Returns nothing user = User . manager . get ( id = 1 , as_json = False ) user . manager . delete () # deleting user object with id=1 Is exists Return a boolean, True if the entities are present in the database, False if the entities are not in the database. Recommended to use to check the presence of an entity in the database is_user_exists = User . manager . is_exists ( id = 1 ) is_user_exists # user with id=1 exists, True True is_user_exists = User . manager . is_exists ( id = 100 ) is_user_exists # user with id=100 does not exists, False False","title":"CRUD operations"},{"location":"database/crud/#get","text":"Get always returns a single object. If the requested object is not in the database, it will raise an error User . manager . get ( id = 1 ) # returns python dict { 'id' : 1 , 'username' : 'some1' , 'email' : 'email1' } User . manager . get ( id = 1 , as_json = False ) # returns user object '<User: 1>' User . manager . get ( id = 100 ) # user with id 100 does not exists \"ModelDoesNotExists: 'User' with {'id': 100} does not exists\"","title":"Get"},{"location":"database/crud/#filter","text":"Filter returns a list of objects. If the objects are not found in the database, it will return an empty list User . manager . filter ( id = 1 ) # returns python list of dicts [ { 'id' : 1 , 'username' : 'some1' , 'email' : 'email1' } ] User . manager . filter ( id__in = ( 1 , 2 ), as_json = False ) # returns list of user objects [ '<User: 1>' , '<User: 2>' ] # no such users in our database, filter will return empty list User . manager . filter ( id__in = ( 100 , 200 )) []","title":"Filter"},{"location":"database/crud/#create","text":"Creates an object and returns the created object. Values for creation are taken from the fields of the model User . manager . create () # create user with some random values { 'id' : 9 , 'username' : 'pF8i78S0ncdatjR5UDYE6uMDg5yxEwLk' , 'email' : 'i7KbUPGrNGBr5yW9mu6lD6JPMxX3FnKCaTQlSuwR9fLM' } # override username with custom value, instead of random User . manager . create ( username = 'custom' ) { 'id' : 32 , 'username' : 'custom' , 'email' : 'BzpzI8cc54ztqJLCgo7gUCYe8BhGzZxgt7c63l' } User . manager . create ( id = 100 , as_json = False ) # returns user object '<User: 100>'","title":"Create"},{"location":"database/crud/#update","text":"Allows you to update the object. Returns the updated object user = User . manager . get ( id = 1 , as_json = False ) user = user . manager . update ( username = 'new_username' , as_json = False ) user # returns user object '<User: 1>' user . username # updated username value 'new_username'","title":"Update"},{"location":"database/crud/#delete","text":"Removes an object from the database. Returns nothing user = User . manager . get ( id = 1 , as_json = False ) user . manager . delete () # deleting user object with id=1","title":"Delete"},{"location":"database/crud/#is-exists","text":"Return a boolean, True if the entities are present in the database, False if the entities are not in the database. Recommended to use to check the presence of an entity in the database is_user_exists = User . manager . is_exists ( id = 1 ) is_user_exists # user with id=1 exists, True True is_user_exists = User . manager . is_exists ( id = 100 ) is_user_exists # user with id=100 does not exists, False False","title":"Is exists"},{"location":"database/operators/","text":"Operators are equivalent to SQL functions/operators that we can use from our python code to query the database Supported operators Operator SQL equivalent Example __in IN id__in=(1, 2, 3) __not_in NOT IN id__not_in=(1, 2, 3) __not_equal != id__not_equal=5 __lt < id__lt=5 __le <= id__le=5 __gt > id__gt=5 __ge >= id__ge=5 __like LIKE email__like='@mail.com'","title":"Operators"},{"location":"database/operators/#supported-operators","text":"Operator SQL equivalent Example __in IN id__in=(1, 2, 3) __not_in NOT IN id__not_in=(1, 2, 3) __not_equal != id__not_equal=5 __lt < id__lt=5 __le <= id__le=5 __gt > id__gt=5 __ge >= id__ge=5 __like LIKE email__like='@mail.com'","title":"Supported operators"},{"location":"database/query/","text":"Q - query node Used to build filters based on binary operators. Helps build more complex database queries Q is a class that allows us to make complex database queries. For example, if we need to make a logical query with the operators \"and\", \"or\" or even combine several operators at once. By itself, Q is not intended to be used like regular classes. This class is based on logical operators, with the help of which it builds a query. Let's analyze the simplest example of how a query is built using Q: from models_manager import Q Q ( id__in = ( 1 , 2 , 3 )) '\" {model} \".\"id\" IN (1, 2, 3)' From the example above, we can see that our python code has turned into SQL code, thanks to the Q class. id converted to \"{model}\".\"id\" __in converted to SQL IN (1, 2, 3) converted to SQL (1, 2, 3) Now let's complicate the example and add a few more arguments to our Q from models_manager import Q Q ( id__in = ( 1 , 2 , 3 ), id__lt = 5 ) '\" {model} \".\"id\" IN (1, 2, 3) AND \" {model} \".\"id\" < 5' id converted to \"{model}\".\"id\" __lt converted to SQL < 5 converted to 5 Note Note that our expressions are now connected with the AND operator, which is the default for such expressions. But it can be changed by passing the default argument inside our Q from models_manager import Q Q ( id__in = ( 1 , 2 , 3 ), id__lt = 5 , default = Q . OR ) '\" {model} \".\"id\" IN (1, 2, 3) OR \" {model} \".\"id\" < 5' Now we see that the expressions are connected via the OR operator. Let's now connect the two examples above. To be shared by the AND operator from models_manager import Q Q ( id__in = ( 1 , 2 , 3 ), id__lt = 5 ) | Q ( id__in = ( 1 , 2 , 3 ), id__lt = 5 , default = Q . OR ) \"\"\" (\"{model}\".\"id\" IN (1, 2, 3) AND \"{model}\".\"id\" < 5) OR (\"{model}\".\"id\" IN (1, 2, 3) OR \"{model}\".\"id\" < 5) \"\"\" We got an example, which is connected, through the OR operator Consider the use of logical operators on the example of the user model from models_manager import Model , Field from models_manager.utils import random_number , random_string class User ( Model ): identity = 'users' database = 'stuff' id = Field ( default = random_number , category = int ) username = Field ( default = random_string , category = str ) email = Field ( default = random_string , category = str ) def __str__ ( self ): return f '<User: { self . id } >' OR | - Bitwise OR from models_manager import Q User . manager . filter ( Q ( id__in = ( 1 , 2 )) | Q ( username = 'some' )) AND & - Bitwise AND from models_manager import Q User . manager . filter ( Q ( id__in = ( 1 , 2 )) & Q ( username = 'some' )) OR + AND from models_manager import Q User . manager . filter ( ( Q ( id__in = ( 1 , 2 )) & Q ( username = 'some' )) | ( Q ( id__lt = 100 ) & Q ( username__like = 'other' )) ) Above were an example of how you can build logical expressions for database queries","title":"Query"},{"location":"database/query/#q-query-node","text":"Used to build filters based on binary operators. Helps build more complex database queries Q is a class that allows us to make complex database queries. For example, if we need to make a logical query with the operators \"and\", \"or\" or even combine several operators at once. By itself, Q is not intended to be used like regular classes. This class is based on logical operators, with the help of which it builds a query. Let's analyze the simplest example of how a query is built using Q: from models_manager import Q Q ( id__in = ( 1 , 2 , 3 )) '\" {model} \".\"id\" IN (1, 2, 3)' From the example above, we can see that our python code has turned into SQL code, thanks to the Q class. id converted to \"{model}\".\"id\" __in converted to SQL IN (1, 2, 3) converted to SQL (1, 2, 3) Now let's complicate the example and add a few more arguments to our Q from models_manager import Q Q ( id__in = ( 1 , 2 , 3 ), id__lt = 5 ) '\" {model} \".\"id\" IN (1, 2, 3) AND \" {model} \".\"id\" < 5' id converted to \"{model}\".\"id\" __lt converted to SQL < 5 converted to 5 Note Note that our expressions are now connected with the AND operator, which is the default for such expressions. But it can be changed by passing the default argument inside our Q from models_manager import Q Q ( id__in = ( 1 , 2 , 3 ), id__lt = 5 , default = Q . OR ) '\" {model} \".\"id\" IN (1, 2, 3) OR \" {model} \".\"id\" < 5' Now we see that the expressions are connected via the OR operator. Let's now connect the two examples above. To be shared by the AND operator from models_manager import Q Q ( id__in = ( 1 , 2 , 3 ), id__lt = 5 ) | Q ( id__in = ( 1 , 2 , 3 ), id__lt = 5 , default = Q . OR ) \"\"\" (\"{model}\".\"id\" IN (1, 2, 3) AND \"{model}\".\"id\" < 5) OR (\"{model}\".\"id\" IN (1, 2, 3) OR \"{model}\".\"id\" < 5) \"\"\" We got an example, which is connected, through the OR operator Consider the use of logical operators on the example of the user model from models_manager import Model , Field from models_manager.utils import random_number , random_string class User ( Model ): identity = 'users' database = 'stuff' id = Field ( default = random_number , category = int ) username = Field ( default = random_string , category = str ) email = Field ( default = random_string , category = str ) def __str__ ( self ): return f '<User: { self . id } >'","title":"Q - query node"},{"location":"database/query/#or","text":"| - Bitwise OR from models_manager import Q User . manager . filter ( Q ( id__in = ( 1 , 2 )) | Q ( username = 'some' ))","title":"OR"},{"location":"database/query/#and","text":"& - Bitwise AND from models_manager import Q User . manager . filter ( Q ( id__in = ( 1 , 2 )) & Q ( username = 'some' ))","title":"AND"},{"location":"database/query/#or-and","text":"from models_manager import Q User . manager . filter ( ( Q ( id__in = ( 1 , 2 )) & Q ( username = 'some' )) | ( Q ( id__lt = 100 ) & Q ( username__like = 'other' )) ) Above were an example of how you can build logical expressions for database queries","title":"OR + AND"},{"location":"database/setup/","text":"Currently, only PostgreSQL is supported. If you need a custom manager for the database, then you can inherit from the ModelManager and override the necessary methods for the database. Let's prepare our project to interact with the database The first thing we need to do is add settings. In your settings.py or any other settings file, import the database manager settings import models_manager.settings Now we will specify the credentials for connecting to the database import os import models_manager.settings models_manager . settings . DATABASE = { 'host' : os . environ . get ( 'DB_HOST' , 'some.db.host' ), 'port' : os . environ . get ( 'DB_POST' , 5432 ), 'user' : os . environ . get ( 'DB_USER' , 'user' ), 'password' : os . environ . get ( 'DB_PASSWORD' , 'password' ), } Next, we need to point to the database or databases, if we have more than one, to which we want to connect. import os import models_manager.settings models_manager . settings . DATABASE = { 'host' : os . environ . get ( 'HOST' , 'some.db.host' ), 'port' : os . environ . get ( 'POST' , 5432 ), 'user' : os . environ . get ( 'USER' , 'user' ), 'password' : os . environ . get ( 'PASSWORD' , 'password' ), } models_manager . settings . DATABASES = [ 'projects' , 'stuff' , 'common' ] Optional setting for outputting a query to the database import os import models_manager.settings models_manager . settings . DATABASE = { 'host' : os . environ . get ( 'HOST' , 'some.db.host' ), 'port' : os . environ . get ( 'POST' , 5432 ), 'user' : os . environ . get ( 'USER' , 'user' ), 'password' : os . environ . get ( 'PASSWORD' , 'password' ), } models_manager . settings . DATABASES = [ 'projects' , 'stuff' , 'common' ] models_manager . settings . DATABASE_LOGGING = True Now in our model, through which we want to interact with the database, we need to add arguments identity , database from models_manager import Model , Field class User ( Model ): identity = 'user_id' database = 'stuff' user_id = Field ( json = 'id' ) username = Field ( json = 'username' ) identity - Used to specify the table ID, usually the primary key database - The name of the database in which this model resides. This will give the manager an idea which database connection to use to execute the query. That's all, now you can use the model you need to interact with the database","title":"Setup"},{"location":"models/annotation/","text":"Models can also be used to annotate arguments or return values import uuid from requests import post from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'email@gmail.com' , json = 'email' ) def create_user ( user : User ) -> User : # accepting user object ... user_json = user . manager . to_json # getting user object as dict json_response = post ( f 'user/ { user . id . value } ' , json = user_json ) . json () return User ( ** json_response ) new_user = User ( ** User . manager . to_json ) user = create_user ( new_user ) # will return created user object user . id . value 1 user . username . value 'some' user . email . value 'email@gmail.com'","title":"Annotation"},{"location":"models/dict/","text":"Generating dynamic json object based on model. This is one of the most powerful feature of using models Generating json based on model Let's imagine that we have a user object, and we need to get this object with random values each time { \"id\" : \"3fa85f64-5717-4562-b3fc-2c963f66afa6\" , \"username\" : \"some random username\" , \"email\" : \"some random email\" } So let's create a model which will generate us json above Note Id should be dynamic value. Usually when we write auto tests, we use dynamic values. Just like our API can't always accept static values, and vice versa they must be unique each time import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' , category = str ) username = Field ( default = random_string , json = 'username' , category = str ) email = Field ( default = random_string , json = 'email' , category = str ) Let's see what's going on here import uuid from models_manager.utils import random_string callable ( uuid . uuid4 ) # True callable ( random_string ) # True callable ( uuid . uuid4 ()) # False callable ( random_string ()) # False In this case, uuid4, random_string are callable objects. When generating json, these objects will be called and return values will be obtained from them Let's try to use our user model and generate random json import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' , category = str ) username = Field ( default = random_string , json = 'username' , category = str ) email = Field ( default = random_string , json = 'email' , category = str ) User . manager . to_dict () { 'id' : '992ae8a2-ab6d-4d16-a7fd-e009bdcbff4c' , 'username' : 'P8aNC414bqfSZEyUVpgZZQt' , 'email' : 'UDxG3bKhvlLuM8n1LFCtfbZqwlKihogkL6BM8gfVIVk28' } User . manager . to_dict () { 'id' : 'b3a02f98-7691-4a30-a42d-a1a3c600b584' , 'username' : 'XUzl4QLP5mENis0tadeqacSSHf0vwaySeGQgV7S64R2M' , 'email' : 'h1OnsjE5s1UXwTeEpuB5GbPPLF8' } Now we get random json values every time we call the to_dict() method Json key The json_key argument is used to control the keys that will be used when serializing the object into a dictionary Consider an example where the field names differ from their names in json view from typing import Optional from models_manager import Model , Field class User ( Model ): id = Field ( json = 'Id' , category = Optional [ str ]) username = Field ( json = 'Username' , category = Optional [ str ]) User . manager . to_dict ( json_key = False ) { 'id' : None , 'username' : None } User . manager . to_dict ( json_key = True ) { 'Id' : None , 'Username' : None } From the example above, we see that if json_key=True , then we get a dictionary with json keys, otherwise we get the original field names Exclude To exclude fields that will be in the model dictionary, you can use the exclude parameter. The arguments are a list of Field objects or a list of fields as strings from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) username = Field ( json = 'username' , category = str , default = 'some' ) User . manager . to_dict ( exclude = [ User . id ]) { 'username' : 'some' } User . manager . to_dict ( exclude = [ 'id' ]) { 'username' : 'some' } Now we can see that the id field has been excluded from the model dictionary You can also exclude fields when creating an object from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) username = Field ( json = 'username' , category = str , default = 'some' ) user = User ( exclude_dict = [ User . id ]) user . manager . to_dict () { 'username' : 'some' } user = User ( exclude_dict = [ 'id' ]) user . manager . to_dict () { 'username' : 'some' } If you specify the fields to be excluded as strings, then you must specify their format in json","title":"Dict"},{"location":"models/dict/#generating-json-based-on-model","text":"Let's imagine that we have a user object, and we need to get this object with random values each time { \"id\" : \"3fa85f64-5717-4562-b3fc-2c963f66afa6\" , \"username\" : \"some random username\" , \"email\" : \"some random email\" } So let's create a model which will generate us json above Note Id should be dynamic value. Usually when we write auto tests, we use dynamic values. Just like our API can't always accept static values, and vice versa they must be unique each time import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' , category = str ) username = Field ( default = random_string , json = 'username' , category = str ) email = Field ( default = random_string , json = 'email' , category = str ) Let's see what's going on here import uuid from models_manager.utils import random_string callable ( uuid . uuid4 ) # True callable ( random_string ) # True callable ( uuid . uuid4 ()) # False callable ( random_string ()) # False In this case, uuid4, random_string are callable objects. When generating json, these objects will be called and return values will be obtained from them Let's try to use our user model and generate random json import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' , category = str ) username = Field ( default = random_string , json = 'username' , category = str ) email = Field ( default = random_string , json = 'email' , category = str ) User . manager . to_dict () { 'id' : '992ae8a2-ab6d-4d16-a7fd-e009bdcbff4c' , 'username' : 'P8aNC414bqfSZEyUVpgZZQt' , 'email' : 'UDxG3bKhvlLuM8n1LFCtfbZqwlKihogkL6BM8gfVIVk28' } User . manager . to_dict () { 'id' : 'b3a02f98-7691-4a30-a42d-a1a3c600b584' , 'username' : 'XUzl4QLP5mENis0tadeqacSSHf0vwaySeGQgV7S64R2M' , 'email' : 'h1OnsjE5s1UXwTeEpuB5GbPPLF8' } Now we get random json values every time we call the to_dict() method","title":"Generating json based on model"},{"location":"models/dict/#json-key","text":"The json_key argument is used to control the keys that will be used when serializing the object into a dictionary Consider an example where the field names differ from their names in json view from typing import Optional from models_manager import Model , Field class User ( Model ): id = Field ( json = 'Id' , category = Optional [ str ]) username = Field ( json = 'Username' , category = Optional [ str ]) User . manager . to_dict ( json_key = False ) { 'id' : None , 'username' : None } User . manager . to_dict ( json_key = True ) { 'Id' : None , 'Username' : None } From the example above, we see that if json_key=True , then we get a dictionary with json keys, otherwise we get the original field names","title":"Json key"},{"location":"models/dict/#exclude","text":"To exclude fields that will be in the model dictionary, you can use the exclude parameter. The arguments are a list of Field objects or a list of fields as strings from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) username = Field ( json = 'username' , category = str , default = 'some' ) User . manager . to_dict ( exclude = [ User . id ]) { 'username' : 'some' } User . manager . to_dict ( exclude = [ 'id' ]) { 'username' : 'some' } Now we can see that the id field has been excluded from the model dictionary You can also exclude fields when creating an object from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) username = Field ( json = 'username' , category = str , default = 'some' ) user = User ( exclude_dict = [ User . id ]) user . manager . to_dict () { 'username' : 'some' } user = User ( exclude_dict = [ 'id' ]) user . manager . to_dict () { 'username' : 'some' } If you specify the fields to be excluded as strings, then you must specify their format in json","title":"Exclude"},{"location":"models/inheritance/","text":"Model extension Continuing with the user model example, let's imagine that we need to extend this model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) So now we have new \"User\" object { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"token\" : \"some-token\" , \"tenant\" : { \"id\" : 1 , \"name\" : \"Customer\" } } Let's upgrade our \"User\" model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) tenant = { \"id\" : 1 , \"name\" : \"Customer\" } class CustomerUser ( User ): token = Field ( default = 'some-token' , json = 'token' ) tenant = Field ( default = tenant , json = 'tenant' ) So now we can get \"User\" and \"CustomerUser\" objects json without duplicating same fields from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) tenant = { \"id\" : 1 , \"name\" : \"Customer\" } class CustomerUser ( User ): token = Field ( default = 'some-token' , json = 'token' ) tenant = Field ( default = tenant , json = 'tenant' ) CustomerUser . manager . to_json { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"token\" : \"some-token\" , \"tenant\" : { \"id\" : 1 , \"name\" : \"Customer\" } } For example, we need to override some field with new value { \"id\" : 1 , \"username\" : \"another\" , \"email\" : \"other\" } Let's do this from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) class SpecialUser ( User ): username = Field ( default = 'another' , json = 'username' ) SpecialUser . manager . to_json { \"id\" : 1 , \"username\" : \"another\" , \"email\" : \"other\" } This way we can overwrite the attributes of the parent model Field exclusion Using the user as an example, let's look at how to exclude model fields from models_manager import Model , Field class ComplicatedUser ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) details = Field ( default = {}, json = 'details' , category = dict ) class SimpleUser ( ComplicatedUser ): class Config : exclude_fields = [ 'details' , 'email' ] We created the ComplicatedUser model and inherited the SimpleUser model from it, in which the email, details fields were excluded. Let's now serialize the model and look at the dictionary from models_manager import Model , Field class ComplicatedUser ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) details = Field ( default = {}, json = 'details' , category = dict ) class SimpleUser ( ComplicatedUser ): class Config : exclude_fields = [ 'details' , 'email' ] SimpleUser . manager . to_dict () { 'id' : 1 , 'username' : 'some' }","title":"Inheritance"},{"location":"models/inheritance/#model-extension","text":"Continuing with the user model example, let's imagine that we need to extend this model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) So now we have new \"User\" object { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"token\" : \"some-token\" , \"tenant\" : { \"id\" : 1 , \"name\" : \"Customer\" } } Let's upgrade our \"User\" model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) tenant = { \"id\" : 1 , \"name\" : \"Customer\" } class CustomerUser ( User ): token = Field ( default = 'some-token' , json = 'token' ) tenant = Field ( default = tenant , json = 'tenant' ) So now we can get \"User\" and \"CustomerUser\" objects json without duplicating same fields from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) tenant = { \"id\" : 1 , \"name\" : \"Customer\" } class CustomerUser ( User ): token = Field ( default = 'some-token' , json = 'token' ) tenant = Field ( default = tenant , json = 'tenant' ) CustomerUser . manager . to_json { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"token\" : \"some-token\" , \"tenant\" : { \"id\" : 1 , \"name\" : \"Customer\" } } For example, we need to override some field with new value { \"id\" : 1 , \"username\" : \"another\" , \"email\" : \"other\" } Let's do this from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) class SpecialUser ( User ): username = Field ( default = 'another' , json = 'username' ) SpecialUser . manager . to_json { \"id\" : 1 , \"username\" : \"another\" , \"email\" : \"other\" } This way we can overwrite the attributes of the parent model","title":"Model extension"},{"location":"models/inheritance/#field-exclusion","text":"Using the user as an example, let's look at how to exclude model fields from models_manager import Model , Field class ComplicatedUser ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) details = Field ( default = {}, json = 'details' , category = dict ) class SimpleUser ( ComplicatedUser ): class Config : exclude_fields = [ 'details' , 'email' ] We created the ComplicatedUser model and inherited the SimpleUser model from it, in which the email, details fields were excluded. Let's now serialize the model and look at the dictionary from models_manager import Model , Field class ComplicatedUser ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) details = Field ( default = {}, json = 'details' , category = dict ) class SimpleUser ( ComplicatedUser ): class Config : exclude_fields = [ 'details' , 'email' ] SimpleUser . manager . to_dict () { 'id' : 1 , 'username' : 'some' }","title":"Field exclusion"},{"location":"models/json/","text":"Warning The to_json method has been deprecated and will be removed in a future releases. Use to_dict instead Generating dynamic json object based on model. This is one of the most powerful feature of using models Generating json based on model Let's imagine that we have a user object, and we need to get this object with random values each time { \"id\" : \"3fa85f64-5717-4562-b3fc-2c963f66afa6\" , \"username\" : \"some random username\" , \"email\" : \"some random email\" } So let's create a model which will generate us json above Note Id should be dynamic value. Usually when we write auto tests, we use dynamic values. Just like our API can't always accept static values, and vice versa they must be unique each time import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' ) username = Field ( default = random_string , json = 'username' ) email = Field ( default = random_string , json = 'email' ) Let's see what's going on here import uuid from models_manager.utils import random_string callable ( uuid . uuid4 ) # True callable ( random_string ) # True callable ( uuid . uuid4 ()) # False callable ( random_string ()) # False In this case, uuid4, random_string are callable objects. When generating json, these objects will be called and return values will be obtained from them Let's try to use our user model and generate random json import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' ) username = Field ( default = random_string , json = 'username' ) email = Field ( default = random_string , json = 'email' ) User . manager . to_json { 'id' : '992ae8a2-ab6d-4d16-a7fd-e009bdcbff4c' , 'username' : 'P8aNC414bqfSZEyUVpgZZQt' , 'email' : 'UDxG3bKhvlLuM8n1LFCtfbZqwlKihogkL6BM8gfVIVk28' } User . manager . to_json { 'id' : 'b3a02f98-7691-4a30-a42d-a1a3c600b584' , 'username' : 'XUzl4QLP5mENis0tadeqacSSHf0vwaySeGQgV7S64R2M' , 'email' : 'h1OnsjE5s1UXwTeEpuB5GbPPLF8' } Now we get random json values every time we call the to_json method Generating negative json based on model Let's now imagine that we need to generate a negative json to test for an error in our API Note To generate negative json, we need to describe the fields in our model in more detail. This is necessary to more accurately generate negative json Now we will extend our model and add new field attributes to it. Imagine that the business logic of our product requests: id not null username should be up to 100 symbols, might be null email should be up to 70 symbols, not null Let's describe it in our model import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' , null = False ) username = Field ( default = random_string , json = 'username' , max_length = 100 , null = True ) email = Field ( default = random_string , json = 'email' , max_length = 70 , null = False ) Now let's try to generate negative json based on the model import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' , null = False ) username = Field ( default = random_string , json = 'username' , max_length = 100 , null = True ) email = Field ( default = random_string , json = 'email' , max_length = 70 , null = False ) User . manager . to_negative_json () { 'id' : None , 'username' : 'DV3CTqGsrXy95cXtCYniEE0BARnvmZTru0jhRFjEg7c4HZEsDHqo8TxkJbIh5FalDWNV2Cknu4OoeQ9CWyymfYvPUp9sXCvgbm13Eq1opfsVjiwbeIhTZo4gOyIbXDtbpg6vMHwuY1N' , 'email' : None } Based on the business logic we described in the model, we generated a negative json that we can use in our test to test the negative scenario for the endpoint API Overriding negative json provider You can make your own negative json generator. For that you have to override default negative json provider class. More info here","title":"Json"},{"location":"models/json/#generating-json-based-on-model","text":"Let's imagine that we have a user object, and we need to get this object with random values each time { \"id\" : \"3fa85f64-5717-4562-b3fc-2c963f66afa6\" , \"username\" : \"some random username\" , \"email\" : \"some random email\" } So let's create a model which will generate us json above Note Id should be dynamic value. Usually when we write auto tests, we use dynamic values. Just like our API can't always accept static values, and vice versa they must be unique each time import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' ) username = Field ( default = random_string , json = 'username' ) email = Field ( default = random_string , json = 'email' ) Let's see what's going on here import uuid from models_manager.utils import random_string callable ( uuid . uuid4 ) # True callable ( random_string ) # True callable ( uuid . uuid4 ()) # False callable ( random_string ()) # False In this case, uuid4, random_string are callable objects. When generating json, these objects will be called and return values will be obtained from them Let's try to use our user model and generate random json import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' ) username = Field ( default = random_string , json = 'username' ) email = Field ( default = random_string , json = 'email' ) User . manager . to_json { 'id' : '992ae8a2-ab6d-4d16-a7fd-e009bdcbff4c' , 'username' : 'P8aNC414bqfSZEyUVpgZZQt' , 'email' : 'UDxG3bKhvlLuM8n1LFCtfbZqwlKihogkL6BM8gfVIVk28' } User . manager . to_json { 'id' : 'b3a02f98-7691-4a30-a42d-a1a3c600b584' , 'username' : 'XUzl4QLP5mENis0tadeqacSSHf0vwaySeGQgV7S64R2M' , 'email' : 'h1OnsjE5s1UXwTeEpuB5GbPPLF8' } Now we get random json values every time we call the to_json method","title":"Generating json based on model"},{"location":"models/json/#generating-negative-json-based-on-model","text":"Let's now imagine that we need to generate a negative json to test for an error in our API Note To generate negative json, we need to describe the fields in our model in more detail. This is necessary to more accurately generate negative json Now we will extend our model and add new field attributes to it. Imagine that the business logic of our product requests: id not null username should be up to 100 symbols, might be null email should be up to 70 symbols, not null Let's describe it in our model import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' , null = False ) username = Field ( default = random_string , json = 'username' , max_length = 100 , null = True ) email = Field ( default = random_string , json = 'email' , max_length = 70 , null = False ) Now let's try to generate negative json based on the model import uuid from models_manager import Model , Field from models_manager.utils import random_string class User ( Model ): id = Field ( default = uuid . uuid4 , json = 'id' , null = False ) username = Field ( default = random_string , json = 'username' , max_length = 100 , null = True ) email = Field ( default = random_string , json = 'email' , max_length = 70 , null = False ) User . manager . to_negative_json () { 'id' : None , 'username' : 'DV3CTqGsrXy95cXtCYniEE0BARnvmZTru0jhRFjEg7c4HZEsDHqo8TxkJbIh5FalDWNV2Cknu4OoeQ9CWyymfYvPUp9sXCvgbm13Eq1opfsVjiwbeIhTZo4gOyIbXDtbpg6vMHwuY1N' , 'email' : None } Based on the business logic we described in the model, we generated a negative json that we can use in our test to test the negative scenario for the endpoint API","title":"Generating negative json based on model"},{"location":"models/json/#overriding-negative-json-provider","text":"You can make your own negative json generator. For that you have to override default negative json provider class. More info here","title":"Overriding negative json provider"},{"location":"models/models/","text":"Model is a class that describes any json object structure. For example, we have such \"User\" json object { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" } Let's create model for that object from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) What we actually did: created an abstraction of the user model described the names of the fields in the user model added values to user model fields Now we can use this model in our auto tests project, for example to get json from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' ) username = Field ( default = 'some' , json = 'username' ) email = Field ( default = 'other' , json = 'email' ) User . manager . to_json { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" }","title":"Basic model"},{"location":"models/negative_dict/","text":"The manager has methods that, based on the model, can generate negative values for fields. Each method accepts a list of fields and negative values will be generated for fields from the list. The fields in the list can be passed as strings or Field objects Dict with negative max length Used to generate a negative value that under length will be greater than the maximum length of the field. Applies to string fields from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , max_length = 100 ) username = Field ( json = 'username' , category = str , max_length = 50 ) User . manager . to_dict_with_negative_max_length ( fields = [ User . username , User . email ]) { 'id' : 1 , # len equal to 120 'email' : '0MJJ3emj7oEug3FA66ppFj8uMakPNojwJ8egZqsVwKqAlD9uSPOtgvpSG9UQnL1n5eYHJSSBVC2P00X3TwMzBdYauDYDoSRiPhAMxJE0T7WOJqGhpomTgVRW' , # len equal to 63 'username' : '04KlqG2SnSsgHfNqTbXckCz2iNA3vwXMAdiPkoLfDAQQZdsN8PKbyMCc0VShFd6' } Dict with negative min length Used to generate negative values that are less than the minimum field value. Applies to string fields from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , min_length = 10 ) username = Field ( json = 'username' , category = str , min_length = 6 ) User . manager . to_dict_with_negative_min_length ( fields = [ User . username , User . email ]) { 'id' : 1 , 'email' : 'TNiXpglfh' , # len equal to 9 'username' : 'ohOsy' # len equal to 5 } Dict with null fields Used to generate an object dictionary with negative values equal to None/null . Can be applied to any field types from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , default = 'email' ) username = Field ( json = 'username' , category = str , default = 'username' ) User . manager . to_dict_with_null_fields ( fields = [ User . username , User . email ]) { 'id' : 1 , 'email' : None , 'username' : None } Dict with empty strings Used to create a dictionary of objects with negative values equal to the empty string \"\" . Can be applied to any field types from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , default = 'email' ) username = Field ( json = 'username' , category = str , default = 'username' ) User . manager . to_dict_with_empty_string_fields ( fields = [ User . username , User . email ]) { 'id' : 1 , 'email' : '' , 'username' : '' }","title":"Negative dict"},{"location":"models/negative_dict/#dict-with-negative-max-length","text":"Used to generate a negative value that under length will be greater than the maximum length of the field. Applies to string fields from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , max_length = 100 ) username = Field ( json = 'username' , category = str , max_length = 50 ) User . manager . to_dict_with_negative_max_length ( fields = [ User . username , User . email ]) { 'id' : 1 , # len equal to 120 'email' : '0MJJ3emj7oEug3FA66ppFj8uMakPNojwJ8egZqsVwKqAlD9uSPOtgvpSG9UQnL1n5eYHJSSBVC2P00X3TwMzBdYauDYDoSRiPhAMxJE0T7WOJqGhpomTgVRW' , # len equal to 63 'username' : '04KlqG2SnSsgHfNqTbXckCz2iNA3vwXMAdiPkoLfDAQQZdsN8PKbyMCc0VShFd6' }","title":"Dict with negative max length"},{"location":"models/negative_dict/#dict-with-negative-min-length","text":"Used to generate negative values that are less than the minimum field value. Applies to string fields from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , min_length = 10 ) username = Field ( json = 'username' , category = str , min_length = 6 ) User . manager . to_dict_with_negative_min_length ( fields = [ User . username , User . email ]) { 'id' : 1 , 'email' : 'TNiXpglfh' , # len equal to 9 'username' : 'ohOsy' # len equal to 5 }","title":"Dict with negative min length"},{"location":"models/negative_dict/#dict-with-null-fields","text":"Used to generate an object dictionary with negative values equal to None/null . Can be applied to any field types from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , default = 'email' ) username = Field ( json = 'username' , category = str , default = 'username' ) User . manager . to_dict_with_null_fields ( fields = [ User . username , User . email ]) { 'id' : 1 , 'email' : None , 'username' : None }","title":"Dict with null fields"},{"location":"models/negative_dict/#dict-with-empty-strings","text":"Used to create a dictionary of objects with negative values equal to the empty string \"\" . Can be applied to any field types from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , default = 'email' ) username = Field ( json = 'username' , category = str , default = 'username' ) User . manager . to_dict_with_empty_string_fields ( fields = [ User . username , User . email ]) { 'id' : 1 , 'email' : '' , 'username' : '' }","title":"Dict with empty strings"},{"location":"models/object/","text":"Basic Working with models can be working with objects Let's create an object based on the model from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) user = User ( id = 1 , username = 'some' , email = 'other' ) user . id '<Field: 1>' user . id . value 1 Warning Note that user.id does not return an id value, but a field object that contains data about this field Now let's take a closer look at how we can manipulate our object. from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) user = User ( id = 1 , username = 'some' , email = 'other' ) user . manager . to_dict () { 'id' : 1 , 'username' : 'some' , 'email' : 'other' } From the example above, you can see that our object has a manager attribute. With which we can receive the object as a dictionary, generate a schema, use the object to interact with the database, and so on. List of objects Now let's complicate our model and add nested objects to it. from typing import List from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenants = Field ( json = 'tenants' , category = List [ Tenant ]) tenants = [ Tenant ( id = 1 , name = 'some' ), Tenant ( id = 2 , name = 'Other' )] user = User ( id = 1 , username = 'some' , email = 'other' , tenants = tenants ) We have now added a tenants field to our user, which contains a list of Tenant objects. Now, when creating an object, we specify the tenants parameter and pass a list with Tenant objects there Now let's try to get the value of the tenants field and generate a dictionary from typing import List from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenants = Field ( json = 'tenants' , category = List [ Tenant ]) tenants = [ Tenant ( id = 1 , name = 'some' ), Tenant ( id = 2 , name = 'Other' )] user = User ( id = 1 , username = 'some' , email = 'other' , tenants = tenants ) user . tenants . value '[<Model: Tenant>, <Model: Tenant>]' user . manager . to_dict () { 'id' : 1 , 'username' : 'some' , 'email' : 'other' , 'tenants' : [ { 'id' : 1 , 'name' : 'some' }, { 'id' : 2 , 'name' : 'Other' } ] } From the example above, we see that inside the Users model there are a tenants attribute that contains a list of Tenant objects. When we serialize this object using the to_dict() method, we get a nested object structure Dictionary with object Now let's look at an example in which we will have a dictionary with an object inside from typing import Dict from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenant_ref = Field ( json = 'tenantRef' , category = Dict [ str , Tenant ]) tenant_ref = { 'some' : Tenant ( id = 1 , name = 'some' )} user = User ( id = 1 , username = 'some' , email = 'other' , tenantRef = tenant_ref ) Now we have added the tenant_ref field, which is a dictionary, and inside this dictionary we have a Tenant object. Let's generate a dictionary based on the User model and look at the value of the tenant_ref field Warning Notice that when we created the User object, we specified the tenantRef attribute, not the tenant_ref attribute. When generating a model object, the names of the attributes are passed in the form in which they appear in the json representation from typing import Dict from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenant_ref = Field ( json = 'tenantRef' , category = Dict [ str , Tenant ]) tenant_ref = { 'some' : Tenant ( id = 1 , name = 'some' )} user = User ( id = 1 , username = 'some' , email = 'other' , tenantRef = tenant_ref ) user . tenant_ref . value \"{'some': <Model: Tenant>}\" user . manager . to_dict () { 'id' : 1 , 'username' : 'some' , 'email' : 'other' , 'tenantRef' : { 'some' : { 'id' : 1 , 'name' : 'some' } } } From the example above, we can see that the dictionary with the object was serialized when the to_dict() method was called.","title":"Object model"},{"location":"models/object/#basic","text":"Working with models can be working with objects Let's create an object based on the model from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) user = User ( id = 1 , username = 'some' , email = 'other' ) user . id '<Field: 1>' user . id . value 1 Warning Note that user.id does not return an id value, but a field object that contains data about this field Now let's take a closer look at how we can manipulate our object. from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) user = User ( id = 1 , username = 'some' , email = 'other' ) user . manager . to_dict () { 'id' : 1 , 'username' : 'some' , 'email' : 'other' } From the example above, you can see that our object has a manager attribute. With which we can receive the object as a dictionary, generate a schema, use the object to interact with the database, and so on.","title":"Basic"},{"location":"models/object/#list-of-objects","text":"Now let's complicate our model and add nested objects to it. from typing import List from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenants = Field ( json = 'tenants' , category = List [ Tenant ]) tenants = [ Tenant ( id = 1 , name = 'some' ), Tenant ( id = 2 , name = 'Other' )] user = User ( id = 1 , username = 'some' , email = 'other' , tenants = tenants ) We have now added a tenants field to our user, which contains a list of Tenant objects. Now, when creating an object, we specify the tenants parameter and pass a list with Tenant objects there Now let's try to get the value of the tenants field and generate a dictionary from typing import List from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenants = Field ( json = 'tenants' , category = List [ Tenant ]) tenants = [ Tenant ( id = 1 , name = 'some' ), Tenant ( id = 2 , name = 'Other' )] user = User ( id = 1 , username = 'some' , email = 'other' , tenants = tenants ) user . tenants . value '[<Model: Tenant>, <Model: Tenant>]' user . manager . to_dict () { 'id' : 1 , 'username' : 'some' , 'email' : 'other' , 'tenants' : [ { 'id' : 1 , 'name' : 'some' }, { 'id' : 2 , 'name' : 'Other' } ] } From the example above, we see that inside the Users model there are a tenants attribute that contains a list of Tenant objects. When we serialize this object using the to_dict() method, we get a nested object structure","title":"List of objects"},{"location":"models/object/#dictionary-with-object","text":"Now let's look at an example in which we will have a dictionary with an object inside from typing import Dict from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenant_ref = Field ( json = 'tenantRef' , category = Dict [ str , Tenant ]) tenant_ref = { 'some' : Tenant ( id = 1 , name = 'some' )} user = User ( id = 1 , username = 'some' , email = 'other' , tenantRef = tenant_ref ) Now we have added the tenant_ref field, which is a dictionary, and inside this dictionary we have a Tenant object. Let's generate a dictionary based on the User model and look at the value of the tenant_ref field Warning Notice that when we created the User object, we specified the tenantRef attribute, not the tenant_ref attribute. When generating a model object, the names of the attributes are passed in the form in which they appear in the json representation from typing import Dict from models_manager import Model , Field class Tenant ( Model ): id = Field ( json = 'id' , category = int ) name = Field ( json = 'name' , category = str ) class User ( Model ): id = Field ( json = 'id' , category = int ) username = Field ( json = 'username' , category = str ) email = Field ( json = 'email' , category = str ) tenant_ref = Field ( json = 'tenantRef' , category = Dict [ str , Tenant ]) tenant_ref = { 'some' : Tenant ( id = 1 , name = 'some' )} user = User ( id = 1 , username = 'some' , email = 'other' , tenantRef = tenant_ref ) user . tenant_ref . value \"{'some': <Model: Tenant>}\" user . manager . to_dict () { 'id' : 1 , 'username' : 'some' , 'email' : 'other' , 'tenantRef' : { 'some' : { 'id' : 1 , 'name' : 'some' } } } From the example above, we can see that the dictionary with the object was serialized when the to_dict() method was called.","title":"Dictionary with object"},{"location":"schema/advanced/","text":"Using the model, you can describe absolutely any object. The model supports standard python typing. That is, we can use List[int] , List[str] , Union[str, int] etc. Currently, most of the python types such as List , Dict , Tuple , Union , Optional are supported, as well as models Any nesting of objects is supported, for example List[Dict[str, Union[int, bool]]] List List is used when you can have a list of some objects or just strings or numbers from typing import List from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = List [ int ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'items' : { 'type' : 'number' }, 'type' : 'array' } }, 'required' : [ 'states' ] } Dict Dict is used when you want to describe some object, the object can contain any fields from typing import Dict from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = Dict [ str , int ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'additionalProperties' : { 'type' : 'number' }, 'type' : 'object' } }, 'required' : [ 'states' ] } Union Union is used when you want to describe several types at once. For example, if the field can be a string, a number, a boolean value, or even an object from typing import Union from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = Union [ str , int , bool ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'anyOf' : [ { 'type' : 'string' }, { 'type' : 'number' }, { 'type' : 'boolean' } ] } }, 'required' : [ 'states' ] } Tuple Tuple is used when you have a list of a certain length with certain elements from typing import Tuple from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = Tuple [ str , int , bool ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'maxItems' : 3 , 'minItems' : 3 , 'items' : [ { 'type' : 'string' }, { 'type' : 'number' }, { 'type' : 'boolean' } ], 'type' : 'array' } }, 'required' : [ 'states' ] } Optional Optional is used when the field can be null from typing import Optional from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = Optional [ str ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'anyOf' : [ { 'type' : 'string' }, { 'type' : 'null' } ] } }, 'required' : [ 'states' ] } Nested types Thus, we can describe absolutely any object structure, with any nesting from typing import List , Dict , Union , Optional from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = List [ Dict [ str , Union [ int , str , Optional [ bool ]]]]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'items' : { 'additionalProperties' : { 'anyOf' : [ { 'type' : 'number' }, { 'type' : 'string' }, { 'type' : 'boolean' }, { 'type' : 'null' } ] }, 'type' : 'object' }, 'type' : 'array' } }, 'required' : [ 'states' ] }","title":"Advanced usage"},{"location":"schema/advanced/#list","text":"List is used when you can have a list of some objects or just strings or numbers from typing import List from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = List [ int ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'items' : { 'type' : 'number' }, 'type' : 'array' } }, 'required' : [ 'states' ] }","title":"List"},{"location":"schema/advanced/#dict","text":"Dict is used when you want to describe some object, the object can contain any fields from typing import Dict from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = Dict [ str , int ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'additionalProperties' : { 'type' : 'number' }, 'type' : 'object' } }, 'required' : [ 'states' ] }","title":"Dict"},{"location":"schema/advanced/#union","text":"Union is used when you want to describe several types at once. For example, if the field can be a string, a number, a boolean value, or even an object from typing import Union from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = Union [ str , int , bool ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'anyOf' : [ { 'type' : 'string' }, { 'type' : 'number' }, { 'type' : 'boolean' } ] } }, 'required' : [ 'states' ] }","title":"Union"},{"location":"schema/advanced/#tuple","text":"Tuple is used when you have a list of a certain length with certain elements from typing import Tuple from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = Tuple [ str , int , bool ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'maxItems' : 3 , 'minItems' : 3 , 'items' : [ { 'type' : 'string' }, { 'type' : 'number' }, { 'type' : 'boolean' } ], 'type' : 'array' } }, 'required' : [ 'states' ] }","title":"Tuple"},{"location":"schema/advanced/#optional","text":"Optional is used when the field can be null from typing import Optional from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = Optional [ str ]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'anyOf' : [ { 'type' : 'string' }, { 'type' : 'null' } ] } }, 'required' : [ 'states' ] }","title":"Optional"},{"location":"schema/advanced/#nested-types","text":"Thus, we can describe absolutely any object structure, with any nesting from typing import List , Dict , Union , Optional from models_manager import Model , Field class User ( Model ): states = Field ( json = 'states' , category = List [ Dict [ str , Union [ int , str , Optional [ bool ]]]]) User . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'states' : { 'items' : { 'additionalProperties' : { 'anyOf' : [ { 'type' : 'number' }, { 'type' : 'string' }, { 'type' : 'boolean' }, { 'type' : 'null' } ] }, 'type' : 'object' }, 'type' : 'array' } }, 'required' : [ 'states' ] }","title":"Nested types"},{"location":"schema/array/","text":"Let's analyze an example where we get a list of user objects [ { \"id\" : 1 , \"username\" : \"some1\" , \"email\" : \"other1\" }, { \"id\" : 2 , \"username\" : \"some2\" , \"email\" : \"other2\" }, { \"id\" : 3 , \"username\" : \"some3\" , \"email\" : \"other3\" } ] We can use the same model we did to validate just the user object from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) Now we generate a schema for validating the list of objects from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) User . manager . to_array_schema { 'type' : 'array' , 'items' : { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' }, 'email' : { 'type' : 'string' } }, 'required' : [ 'id' , 'username' , 'email' ] } }","title":"Array"},{"location":"schema/basic/","text":"We can generate json schema to validate json objects. The schema is generated dynamically based on the model. This allows us to control the objects that our API returns to us. In case of non-compliance with the scheme, find bugs and errors Suppose we have an API that returns json { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" } Let's describe the model that will describe the returned json and validate it from jsonschema import validate from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str , max_length = 100 ) email = Field ( default = 'other' , json = 'email' , category = str , max_length = 70 ) user_json = get_user () . json () schema = User . manager . to_schema validate ( instance = user_json , schema = schema ) Exclude schema If you want to dynamically exclude fields from the json schema, then there is the exclude_schema parameter for this. As values, a list of fields is passed as strings or Field objects from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , max_length = 100 ) username = Field ( json = 'username' , category = str , max_length = 50 ) user = User ( exclude_schema = [ User . id , User . email ]) user . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'username' : { 'maxLength' : 50 , 'type' : 'string' } }, 'required' : [ 'username' ] }","title":"Basic"},{"location":"schema/basic/#exclude-schema","text":"If you want to dynamically exclude fields from the json schema, then there is the exclude_schema parameter for this. As values, a list of fields is passed as strings or Field objects from models_manager import Model , Field class User ( Model ): id = Field ( json = 'id' , category = int , default = 1 ) email = Field ( json = 'email' , category = str , max_length = 100 ) username = Field ( json = 'username' , category = str , max_length = 50 ) user = User ( exclude_schema = [ User . id , User . email ]) user . manager . to_schema { 'title' : 'User' , 'type' : 'object' , 'properties' : { 'username' : { 'maxLength' : 50 , 'type' : 'string' } }, 'required' : [ 'username' ] }","title":"Exclude schema"},{"location":"schema/enum/","text":"Now let's imagine that our user has a role field that can only have a certain set of values. According to business logic, our user can have the roles of junior , middle , senior , expert { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"role\" : \"junior\" } Let's describe it in terms of a python object from enum import Enum class Roles ( Enum ): JUNIOR = 'junior' MIDDLE = 'middle' SENIOR = 'senior' EXPERT = 'expert' Now let's create a model. Let's describe the role field and indicate that the role field can only have a certain range of values from models_manager import Model , Field , FieldGenericEnum class Roles ( FieldGenericEnum ): JUNIOR = 'junior' MIDDLE = 'middle' SENIOR = 'senior' EXPERT = 'expert' class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) role = Field ( default = Roles . JUNIOR . value , json = 'role' , category = str , choices = Roles . to_list ()) Note We have added a role field to our user model. Notice the choices argument. You can read more about field arguments here Roles.to_list() will return us a list of the available roles. We pass this list as the choices argument inside the role field from models_manager import FieldGenericEnum class Roles ( FieldGenericEnum ): JUNIOR = 'junior' MIDDLE = 'middle' SENIOR = 'senior' EXPERT = 'expert' Roles . to_list () [ 'junior' , 'middle' , 'senior' , 'expert' ] Now we have described the model and the list of available roles. Let's generate a schema from models_manager import Model , Field , FieldGenericEnum class Roles ( FieldGenericEnum ): JUNIOR = 'junior' MIDDLE = 'middle' SENIOR = 'senior' EXPERT = 'expert' class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) role = Field ( default = Roles . JUNIOR . value , json = 'role' , category = str , choices = Roles . to_list ()) User . manager . to_schema { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' }, 'email' : { 'type' : 'string' }, 'role' : { 'type' : 'string' , 'enum' : [ 'junior' , 'middle' , 'senior' , 'expert' ] } }, 'required' : [ 'id' , 'username' , 'email' , 'role' ] } Now we see that role is not just a string, but a string that can only be represented by a certain set of values. This means that if, for example, our API returns to us some invalid choice, for example { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"role\" : \"some error instead of role\" } Then our test will detect this error and fail","title":"Enums"},{"location":"schema/nested_array/","text":"Warning The related_to attrivute is deprecated. Use typing annotation on category attribute. Read more with_models , advanced Let's imagine that our user can belong to several tenants at once { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"tenant\" : [ { \"id\" : \"some1\" , \"name\" : \"Customer1\" }, { \"id\" : \"some2\" , \"name\" : \"Customer2\" } ] } Let's make a model that can validate a list of tenants from models_manager import Model , Field class Tenant ( Model ): id = Field ( default = 'some' , json = 'id' ) name = Field ( default = 'Customer' , json = 'name' ) tenant = { \"id\" : \"some\" , \"name\" : \"Customer\" } class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) tenant = Field ( default = tenant , json = 'tenant' , category = list , related_to = Tenant ) Note Note that now, unlike validating just an object, we specify the list category, this tells our model that tenant is a list of objects Now let's generate a schema for the nested list of objects from models_manager import Model , Field class Tenant ( Model ): id = Field ( default = 'some' , json = 'id' ) name = Field ( default = 'Customer' , json = 'name' ) tenant = { \"id\" : \"some\" , \"name\" : \"Customer\" } class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) tenant = Field ( default = tenant , json = 'tenant' , category = list , related_to = Tenant ) User . manager . to_schema { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' }, 'email' : { 'type' : 'string' }, 'tenant' : { 'type' : 'array' , 'items' : { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'string' }, 'name' : { 'type' : 'string' } }, 'required' : [ 'id' , 'name' ] } } }, 'required' : [ 'id' , 'username' , 'email' , 'tenant' ] }","title":"Nested array"},{"location":"schema/nested_object/","text":"Warning The related_to attrivute is deprecated. Use typing annotation on category attribute. Read more with_models , advanced But we still have a tenant field which is of type object and this is not informative because object can be any json. { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"tenant\" : { \"id\" : \"some\" , \"name\" : \"Customer\" } } Let's describe the tenant object as a model from models_manager import Model , Field class Tenant ( Model ): id = Field ( default = 'some' , json = 'id' ) name = Field ( default = 'Customer' , json = 'name' ) Now let's put everything together and generate a schema for nested json with tenant from models_manager import Model , Field class Tenant ( Model ): id = Field ( default = 'some' , json = 'id' ) name = Field ( default = 'Customer' , json = 'name' ) tenant = { \"id\" : \"some\" , \"name\" : \"Customer\" } class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str , max_length = 100 ) email = Field ( default = 'other' , json = 'email' , category = str , max_length = 70 ) tenant = Field ( default = tenant , json = 'tenant' , category = dict , related_to = Tenant ) User . manager . to_schema { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' , 'minLength' : 0 , 'maxLength' : 100 }, 'email' : { 'type' : 'string' , 'minLength' : 0 , 'maxLength' : 70 }, 'tenant' : { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'string' }, 'name' : { 'type' : 'string' } }, 'required' : [ 'id' , 'name' ] } }, 'required' : [ 'id' , 'username' , 'email' , 'tenant' ] } Now we see that tenant is not just an abstract object, but a concrete object with certain fields. Note Pay attention to the related_to attribute to which we passed the Tenant model object. You can read more about field arguments here","title":"Nested object"},{"location":"schema/object/","text":"Let's go back to the user model and try to validate json { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" } Let's describe our model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) We described the model where we indicated the categories for each field Note You can read more about categories and other field arguments here Now let's generate a schema that will describe how the json of our model should look like. from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) User . manager . to_schema { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' }, 'email' : { 'type' : 'string' } }, 'required' : [ 'id' , 'username' , 'email' ] } From here we see that: id - number username - string email - string Max length Let's add more specifics for some fields from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str , max_length = 100 ) email = Field ( default = 'other' , json = 'email' , category = str , max_length = 70 ) User . manager . to_schema { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' , 'minLength' : 0 , 'maxLength' : 100 }, 'email' : { 'type' : 'string' , 'minLength' : 0 , 'maxLength' : 70 } }, 'required' : [ 'id' , 'username' , 'email' ] } Now we can see that the username is in a certain length range from 0 to 100, just like the email field Required Now let's see how we can validate optional fields in an object. Imagine now that the user object has an optional token field, which may or may not be { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" } Also valid { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"token\" : \"some-token\" } Let's add a new token field to our user model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) token = Field ( default = 'some-token' , json = 'token' , is_related = True ) { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' }, 'email' : { 'type' : 'string' }, 'token' : { 'type' : [ 'string' , 'null' ]} }, 'required' : [ 'id' , 'username' , 'email' ] } Note Notice that we have added the is_related argument to the token field. You can read more about field arguments here","title":"Object"},{"location":"schema/object/#max-length","text":"Let's add more specifics for some fields from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str , max_length = 100 ) email = Field ( default = 'other' , json = 'email' , category = str , max_length = 70 ) User . manager . to_schema { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' , 'minLength' : 0 , 'maxLength' : 100 }, 'email' : { 'type' : 'string' , 'minLength' : 0 , 'maxLength' : 70 } }, 'required' : [ 'id' , 'username' , 'email' ] } Now we can see that the username is in a certain length range from 0 to 100, just like the email field","title":"Max length"},{"location":"schema/object/#required","text":"Now let's see how we can validate optional fields in an object. Imagine now that the user object has an optional token field, which may or may not be { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" } Also valid { \"id\" : 1 , \"username\" : \"some\" , \"email\" : \"other\" , \"token\" : \"some-token\" } Let's add a new token field to our user model from models_manager import Model , Field class User ( Model ): id = Field ( default = 1 , json = 'id' , category = int ) username = Field ( default = 'some' , json = 'username' , category = str ) email = Field ( default = 'other' , json = 'email' , category = str ) token = Field ( default = 'some-token' , json = 'token' , is_related = True ) { 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'username' : { 'type' : 'string' }, 'email' : { 'type' : 'string' }, 'token' : { 'type' : [ 'string' , 'null' ]} }, 'required' : [ 'id' , 'username' , 'email' ] } Note Notice that we have added the is_related argument to the token field. You can read more about field arguments here","title":"Required"},{"location":"schema/with_models/","text":"List of object from typing import List from models_manager import Model , Field class Task ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) class Course ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) tasks = Field ( json = 'tasks' , category = List [ Task ]) Course . manager . to_schema { 'title' : 'Course' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' }, 'tasks' : { 'items' : { 'title' : 'Task' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' } }, 'required' : [ 'id' , 'title' ] }, 'type' : 'array' } }, 'required' : [ 'id' , 'title' , 'tasks' ] } Here we see List[Task] , this type describes a list with Task objects Let's take a closer look at the json schema This schema describes the external Course object. { 'title' : 'Course' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' }, 'tasks' : { ... } }, 'required' : [ 'id' , 'title' , 'tasks' ] } Inside the Course object, there is a nested list of Tasks objects. Below we see a schema nested schema of a list of Tasks objects ... 'tasks' : { 'items' : { 'title' : 'Task' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' } }, 'required' : [ 'id' , 'title' ] }, 'type' : 'array' } ... Single object from models_manager import Model , Field class Task ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) class Course ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) task = Field ( json = 'task' , category = Task ) Course . manager . to_schema { 'title' : 'Course' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' }, 'task' : { 'title' : 'Task' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' } }, 'required' : [ 'id' , 'title' ] } }, 'required' : [ 'id' , 'title' , 'task' ] } Nested types with model from typing import Dict , Optional from models_manager import Model , Field class Task ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) class Course ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) task = Field ( json = 'task' , category = Dict [ str , Optional [ Task ]]) Course . manager . to_schema { 'title' : 'Course' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' }, 'task' : { 'additionalProperties' : { 'anyOf' : [ { 'title' : 'Task' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' } }, 'required' : [ 'id' , 'title' ] }, { 'type' : 'null' } ] }, 'type' : 'object' } }, 'required' : [ 'id' , 'title' , 'task' ] }","title":"With models"},{"location":"schema/with_models/#list-of-object","text":"from typing import List from models_manager import Model , Field class Task ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) class Course ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) tasks = Field ( json = 'tasks' , category = List [ Task ]) Course . manager . to_schema { 'title' : 'Course' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' }, 'tasks' : { 'items' : { 'title' : 'Task' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' } }, 'required' : [ 'id' , 'title' ] }, 'type' : 'array' } }, 'required' : [ 'id' , 'title' , 'tasks' ] } Here we see List[Task] , this type describes a list with Task objects Let's take a closer look at the json schema This schema describes the external Course object. { 'title' : 'Course' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' }, 'tasks' : { ... } }, 'required' : [ 'id' , 'title' , 'tasks' ] } Inside the Course object, there is a nested list of Tasks objects. Below we see a schema nested schema of a list of Tasks objects ... 'tasks' : { 'items' : { 'title' : 'Task' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' } }, 'required' : [ 'id' , 'title' ] }, 'type' : 'array' } ...","title":"List of object"},{"location":"schema/with_models/#single-object","text":"from models_manager import Model , Field class Task ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) class Course ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) task = Field ( json = 'task' , category = Task ) Course . manager . to_schema { 'title' : 'Course' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' }, 'task' : { 'title' : 'Task' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' } }, 'required' : [ 'id' , 'title' ] } }, 'required' : [ 'id' , 'title' , 'task' ] } Nested types with model from typing import Dict , Optional from models_manager import Model , Field class Task ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) class Course ( Model ): id = Field ( json = 'id' , category = int ) title = Field ( json = 'title' , category = str ) task = Field ( json = 'task' , category = Dict [ str , Optional [ Task ]]) Course . manager . to_schema { 'title' : 'Course' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' }, 'task' : { 'additionalProperties' : { 'anyOf' : [ { 'title' : 'Task' , 'type' : 'object' , 'properties' : { 'id' : { 'type' : 'number' }, 'title' : { 'type' : 'string' } }, 'required' : [ 'id' , 'title' ] }, { 'type' : 'null' } ] }, 'type' : 'object' } }, 'required' : [ 'id' , 'title' , 'task' ] }","title":"Single object"}]}